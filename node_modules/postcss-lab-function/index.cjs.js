'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var convertColors = require('@csstools/convert-colors');
var postcss = _interopDefault(require('postcss'));
var parser = _interopDefault(require('postcss-values-parser'));

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var index = postcss.plugin('postcss-lab-function', function (opts) {
	var preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : false;

	return function (root) {
		root.walkDecls(function (decl) {
			var value = decl.value;


			if (colorAnyRegExp.test(value)) {
				var ast = parser(value).parse();

				ast.walkType('func', function (node) {
					if (colorRegExp.test(node.value)) {
						var children = node.nodes.slice(1, -1);
						var isLab = labRegExp.test(node.value);
						var isGray = grayRegExp.test(node.value);
						var isFunctionalLAB = !isGray && matchFunctionalLAB(children);
						var isFunctionalLCH = !isGray && matchFunctionalLCH(children);
						var isFunctionalGray = isGray && matchFunctionalGray(children);

						if (isFunctionalLAB || isFunctionalLCH) {
							node.value = 'rgb';

							var slashNode = children[3];
							var alphaNode = children[4];

							if (alphaNode) {
								if (isPercentage(alphaNode) && !isCalc(alphaNode)) {
									alphaNode.unit = '';
									alphaNode.value = String(alphaNode.value / 100);
								}

								if (alphaNode.value === '1') {
									slashNode.remove();
									alphaNode.remove();
								} else {
									node.value += 'a';
								}
							}

							if (isSlash(slashNode)) {
								slashNode.replaceWith(newComma());
							}

							var converter = isLab ? convertColors.lab2rgb : convertColors.lch2rgb;

							var rgbValues = converter.apply(undefined, _toConsumableArray([children[0].value, children[1].value, children[2].value].map(function (number) {
								return parseFloat(number);
							}))).map(function (sourceValue) {
								return Math.max(Math.min(parseInt(sourceValue * 2.55), 255), 0);
							});

							children[0].value = String(rgbValues[0]);
							children[1].value = String(rgbValues[1]);
							children[2].value = String(rgbValues[2]);

							node.nodes.splice(3, 0, [newComma()]);
							node.nodes.splice(2, 0, [newComma()]);
						} else if (isFunctionalGray) {
							node.value = 'rgb';

							var _alphaNode = children[2];

							var _rgbValues = convertColors.lab2rgb.apply(undefined, _toConsumableArray([children[0].value, 0, 0].map(function (number) {
								return parseFloat(number);
							}))).map(function (sourceValue) {
								return Math.max(Math.min(parseInt(sourceValue * 2.55), 255), 0);
							});

							node.removeAll().append(newParen('(')).append(newNumber(_rgbValues[0])).append(newComma()).append(newNumber(_rgbValues[1])).append(newComma()).append(newNumber(_rgbValues[2])).append(newParen(')'));

							if (_alphaNode) {
								if (isPercentage(_alphaNode) && !isCalc(_alphaNode)) {
									_alphaNode.unit = '';
									_alphaNode.value = String(_alphaNode.value / 100);
								}

								if (_alphaNode.value !== '1') {
									node.value += 'a';

									node.insertBefore(node.last, newComma()).insertBefore(node.last, _alphaNode);
								}
							}
						}
					}
				});

				var newValue = String(ast);

				if (preserve) {
					decl.cloneBefore({ value: newValue });
				} else {
					decl.value = newValue;
				}
			}
		});
	};
});

var colorAnyRegExp = /(^|[^\w-])(lab|lch|gray)\(/i;
var colorRegExp = /^(lab|lch|gray)$/i;
var labRegExp = /^lab$/i;
var grayRegExp = /^gray$/i;
var alphaUnitMatch = /^%?$/i;
var calcFuncMatch = /^calc$/i;
var hueUnitMatch = /^(deg|grad|rad|turn)?$/i;

var isAlphaValue = function isAlphaValue(node) {
	return isCalc(node) || Object(node).type === 'number' && alphaUnitMatch.test(node.unit);
};
var isCalc = function isCalc(node) {
	return Object(node).type === 'func' && calcFuncMatch.test(node.value);
};
var isHue = function isHue(node) {
	return isCalc(node) || Object(node).type === 'number' && hueUnitMatch.test(node.unit);
};
var isNumber = function isNumber(node) {
	return isCalc(node) || Object(node).type === 'number' && node.unit === '';
};
var isPercentage = function isPercentage(node) {
	return isCalc(node) || Object(node).type === 'number' && node.unit === '%';
};
var isSlash = function isSlash(node) {
	return Object(node).type === 'operator' && node.value === '/';
};
var functionalLABMatch = [isNumber, isNumber, isNumber, isSlash, isAlphaValue];
var functionalLCHMatch = [isNumber, isNumber, isHue, isSlash, isAlphaValue];
var functionalGrayMatch = [isNumber, isSlash, isAlphaValue];
var matchFunctionalLAB = function matchFunctionalLAB(children) {
	return children.every(function (child, index) {
		return typeof functionalLABMatch[index] === 'function' && functionalLABMatch[index](child);
	});
};
var matchFunctionalLCH = function matchFunctionalLCH(children) {
	return children.every(function (child, index) {
		return typeof functionalLCHMatch[index] === 'function' && functionalLCHMatch[index](child);
	});
};
var matchFunctionalGray = function matchFunctionalGray(children) {
	return children.every(function (child, index) {
		return typeof functionalGrayMatch[index] === 'function' && functionalGrayMatch[index](child);
	});
};

var newComma = function newComma() {
	return parser.comma({ value: ',' });
};
var newNumber = function newNumber(value) {
	return parser.number({ value });
};
var newParen = function newParen(value) {
	return parser.paren({ value });
};

module.exports = index;
