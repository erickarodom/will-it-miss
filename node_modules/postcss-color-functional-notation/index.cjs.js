'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var postcss = _interopDefault(require('postcss'));
var parser = _interopDefault(require('postcss-values-parser'));

var index = postcss.plugin('postcss-color-functional-notation', function (opts) {
	var preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : false;

	return function (root) {
		root.walkDecls(function (decl) {
			var value = decl.value;


			if (colorAnyRegExp.test(value)) {
				var ast = parser(value).parse();

				ast.walkType('func', function (node) {
					if (colorRegExp.test(node.value)) {
						var children = node.nodes.slice(1, -1);
						var isFunctionalHSL = matchFunctionalHSL(node, children);
						var isFunctionalRGB1 = matchFunctionalRGB1(node, children);
						var isFunctionalRGB2 = matchFunctionalRGB2(node, children);

						if (isFunctionalHSL || isFunctionalRGB1 || isFunctionalRGB2) {
							var slashNode = children[3];
							var alphaNode = children[4];

							if (alphaNode) {
								if (isPercentage(alphaNode) && !isCalc(alphaNode)) {
									alphaNode.unit = '';
									alphaNode.value = String(alphaNode.value / 100);
								}

								if (isHslRgb(node)) {
									node.value += 'a';
								}
							} else if (isHslaRgba(node)) {
								node.value = node.value.slice(0, -1);
							}

							if (isSlash(slashNode)) {
								slashNode.replaceWith(newComma());
							}

							if (isFunctionalRGB2) {
								children[0].unit = children[1].unit = children[2].unit = '';

								children[0].value = String(Math.floor(children[0].value * 255 / 100));
								children[1].value = String(Math.floor(children[1].value * 255 / 100));
								children[2].value = String(Math.floor(children[2].value * 255 / 100));
							}

							node.nodes.splice(3, 0, [newComma()]);
							node.nodes.splice(2, 0, [newComma()]);
						}
					}
				});

				var newValue = String(ast);

				if (preserve) {
					decl.cloneBefore({ value: newValue });
				} else {
					decl.value = newValue;
				}
			}
		});
	};
});

var alphaUnitMatch = /^%?$/i;
var calcFuncMatch = /^calc$/i;
var colorAnyRegExp = /(^|[^\w-])(hsla?|rgba?)\(/i;
var colorRegExp = /^(hsla?|rgba?)$/i;
var hslishRegExp = /^hsla?$/i;
var hslRgbFuncMatch = /^(hsl|rgb)$/i;
var hslaRgbaFuncMatch = /^(hsla|rgba)$/i;
var hueUnitMatch = /^(deg|grad|rad|turn)?$/i;
var rgbishRegExp = /^rgba?$/i;
var isAlphaValue = function isAlphaValue(node) {
	return isCalc(node) || Object(node).type === 'number' && alphaUnitMatch.test(node.unit);
};
var isCalc = function isCalc(node) {
	return Object(node).type === 'func' && calcFuncMatch.test(node.value);
};
var isHue = function isHue(node) {
	return isCalc(node) || Object(node).type === 'number' && hueUnitMatch.test(node.unit);
};
var isNumber = function isNumber(node) {
	return isCalc(node) || Object(node).type === 'number' && node.unit === '';
};
var isPercentage = function isPercentage(node) {
	return isCalc(node) || Object(node).type === 'number' && (node.unit === '%' || node.unit === '' && node.value === '0');
};
var isHslish = function isHslish(node) {
	return Object(node).type === 'func' && hslishRegExp.test(node.value);
};
var isHslRgb = function isHslRgb(node) {
	return Object(node).type === 'func' && hslRgbFuncMatch.test(node.value);
};
var isHslaRgba = function isHslaRgba(node) {
	return Object(node).type === 'func' && hslaRgbaFuncMatch.test(node.value);
};
var isRgbish = function isRgbish(node) {
	return Object(node).type === 'func' && rgbishRegExp.test(node.value);
};
var isSlash = function isSlash(node) {
	return Object(node).type === 'operator' && node.value === '/';
};
var functionalHSLMatch = [isHue, isPercentage, isPercentage, isSlash, isAlphaValue];
var functionalRGB1Match = [isNumber, isNumber, isNumber, isSlash, isAlphaValue];
var functionalRGB2Match = [isPercentage, isPercentage, isPercentage, isSlash, isAlphaValue];

var matchFunctionalHSL = function matchFunctionalHSL(node, children) {
	return isHslish(node) && children.every(function (child, index) {
		return typeof functionalHSLMatch[index] === 'function' && functionalHSLMatch[index](child);
	});
};
var matchFunctionalRGB1 = function matchFunctionalRGB1(node, children) {
	return isRgbish(node) && children.every(function (child, index) {
		return typeof functionalRGB1Match[index] === 'function' && functionalRGB1Match[index](child);
	});
};
var matchFunctionalRGB2 = function matchFunctionalRGB2(node, children) {
	return isRgbish(node) && children.every(function (child, index) {
		return typeof functionalRGB2Match[index] === 'function' && functionalRGB2Match[index](child);
	});
};

var newComma = function newComma() {
	return parser.comma({ value: ',' });
};

module.exports = index;
