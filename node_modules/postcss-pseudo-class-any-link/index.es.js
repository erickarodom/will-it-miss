import postcss from 'postcss';
import parser from 'postcss-selector-parser';

var anyAnyLinkMatch = /:any-link/;

var index = postcss.plugin('postcss-pseudo-class-any-link', function (opts) {
	var preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : true;

	return function (root) {
		// walk each matching rule
		root.walkRules(anyAnyLinkMatch, function (rule) {
			var rawSelector = rule.raws.selector && rule.raws.selector.raw || rule.selector;

			// workaround for https://github.com/postcss/postcss-selector-parser/issues/28#issuecomment-171910556
			if (rawSelector[rawSelector.length - 1] !== ':') {
				// update the selector
				var updatedSelector = parser(function (selectors) {
					// cache variables
					var node = void 0;
					var nodeIndex = void 0;
					var selector = void 0;
					var selectorLink = void 0;
					var selectorVisited = void 0;

					// cache the selector index
					var selectorIndex = -1;

					// for each selector
					while (selector = selectors.nodes[++selectorIndex]) {
						// reset the node index
						nodeIndex = -1;

						// for each node
						while (node = selector.nodes[++nodeIndex]) {
							// if the node value matches the any-link value
							if (node.value === ':any-link') {
								// clone the selector
								selectorLink = selector.clone();
								selectorVisited = selector.clone();

								// update the matching clone values
								selectorLink.nodes[nodeIndex].value = ':link';
								selectorVisited.nodes[nodeIndex].value = ':visited';

								// replace the selector with the clones and roll back the selector index
								selectors.nodes.splice(selectorIndex--, 1, selectorLink, selectorVisited);

								// stop updating the selector
								break;
							}
						}
					}
				}).processSync(rawSelector);

				if (updatedSelector !== rawSelector) {
					if (preserve) {
						rule.cloneBefore({
							selector: updatedSelector
						});
					} else {
						rule.selector = updatedSelector;
					}
				}
			}
		});
	};
});

export default index;
