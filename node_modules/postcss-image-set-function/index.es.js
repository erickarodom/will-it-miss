import postcss from 'postcss';
import parser from 'postcss-values-parser';

// return whether a node is a valid comma
var getComma = (function (node) {
  return Object(node).type === 'comma';
});

var imageSetFunctionMatchRegExp = /^(-webkit-)?image-set$/i;

// return a valid image
var getImage = (function (node) {
	return (
		// <url> | <image()> | <cross-fade()> | <gradient>
		// the image-set() function can not be nested inside of itself
		Object(node).type === 'func' && /^(cross-fade|image|(repeating-)?(conic|linear|radial)-gradient|url)$/i.test(node.value) && !(node.parent.parent && node.parent.parent.type === 'func' && imageSetFunctionMatchRegExp.test(node.parent.parent.value)) ? String(node) : Object(node).type === 'string' ? node.value : false
	);
});

var dpiRatios = { dpcm: 2.54, dpi: 1, dppx: 96, x: 96 };

// return a valid @media rule
var getMedia = (function (node, mediasByDpr) {
	if (Object(node).type === 'number' && node.unit in dpiRatios) {
		// calculate min-device-pixel-ratio and min-resolution
		var dpi = Number(node.value) * dpiRatios[node.unit.toLowerCase()];
		var dpr = Math.floor(dpi / dpiRatios.x * 100) / 100;

		if (dpi in mediasByDpr) {
			return false;
		} else {
			var media = mediasByDpr[dpi] = postcss.atRule({
				name: 'media',
				params: `(-webkit-min-device-pixel-ratio: ${dpr}), (min-resolution: ${dpi}dpi)`
			});

			return media;
		}
	} else {
		return false;
	}
});

var handleInvalidation = (function (opts, message, word) {
	if (opts.oninvalid === 'warn') {
		opts.decl.warn(opts.result, message, { word: String(word) });
	} else if (opts.oninvalid === 'throw') {
		throw opts.decl.error(message, { word: String(word) });
	}
});

var processImageSet = (function (imageSetOptionNodes, decl, opts) {
	var parent = decl.parent;
	var mediasByDpr = {};

	var length = imageSetOptionNodes.length;
	var index = -1;

	while (index < length) {
		var _ref = [index < 0 ? true : getComma(imageSetOptionNodes[index]), getImage(imageSetOptionNodes[index + 1]), getMedia(imageSetOptionNodes[index + 2], mediasByDpr)],
		    comma = _ref[0],
		    value = _ref[1],
		    media = _ref[2];

		// handle invalidations

		if (!comma) {
			return handleInvalidation(opts, 'unexpected comma', imageSetOptionNodes[index]);
		} else if (!value) {
			return handleInvalidation(opts, 'unexpected image', imageSetOptionNodes[index + 1]);
		} else if (!media) {
			return handleInvalidation(opts, 'unexpected resolution', imageSetOptionNodes[index + 2]);
		}

		// prepare @media { decl: <image> }
		var parentClone = parent.clone().removeAll();
		var declClone = decl.clone({ value });

		parentClone.append(declClone);
		media.append(parentClone);

		index += 3;
	}

	var medias = Object.keys(mediasByDpr).sort(function (a, b) {
		return a - b;
	}).map(function (params) {
		return mediasByDpr[params];
	});

	// conditionally prepend previous siblings
	if (medias.length) {
		var firstDecl = medias[0].nodes[0].nodes[0];

		if (medias.length === 1) {
			decl.value = firstDecl.value;
		} else {
			var siblings = parent.nodes;
			var previousSiblings = siblings.slice(0, siblings.indexOf(decl)).concat(firstDecl);

			if (previousSiblings.length) {
				var _parentClone = parent.cloneBefore().removeAll();

				_parentClone.append(previousSiblings);
			}

			// prepend any @media { decl: <image> } rules
			parent.before(medias.slice(1));

			// conditionally remove the current rule
			if (!opts.preserve) {
				decl.remove();

				// and then conditionally remove its parent
				if (!parent.nodes.length) {
					parent.remove();
				}
			}
		}
	}
});

var imageSetValueMatchRegExp = /(^|[^\w-])(-webkit-)?image-set\(/;
var imageSetFunctionMatchRegExp$1 = /^(-webkit-)?image-set$/i;

var index = postcss.plugin('postcss-image-set-function', function (opts) {
	// prepare options
	var preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : true;
	var oninvalid = 'oninvalid' in Object(opts) ? opts.oninvalid : 'ignore';

	return function (root, result) {
		// for every declaration
		root.walkDecls(function (decl) {
			var value = decl.value;

			// if a declaration likely uses an image-set() function

			if (imageSetValueMatchRegExp.test(value)) {
				var ast = parser(value).parse();

				// process every image-set() function
				ast.walkType('func', function (node) {
					if (imageSetFunctionMatchRegExp$1.test(node.value)) {
						processImageSet(node.nodes.slice(1, -1), decl, { decl, oninvalid, preserve, result });
					}
				});
			}
		});
	};
});

export default index;
